#!/bin/bash
############################################################################
#
# MODULE:       v.swathwidth
# AUTHOR(S):	David Finlayson (with help from Hamish via the list), 2006
#               david.p.finlayson@gmail.com
#
# PURPOSE:	Creates a vector map representing the sea bottom coverage of
#               a multibeam survey
#
# COPYRIGHT:	(C) 2006 by the GRASS Development Team
#
#		This program is free software under the GNU General Public
#		License (>=v2). Read the file COPYING that comes with GRASS
#		for details.
#
#############################################################################
#
# April 2006 - First version of the script posted to GRASS

#%Module
#%  description: Estimate multibeam bottom coverage (swath width) along a survey track line
#%End
#%option
#% key: trackline
#% type: string
#% gisprompt: old,vector,vector
#% description: Vector line representing survey track
#% required : yes
#%end
#%option
#% key: elevation
#% type: string
#% gisprompt: old,cell,raster
#% description: Raster DEM of survey area (negative values = below sea level)
#% required : yes
#%end
#%option
#% key: out
#% type: string
#% gisprompt: new,vector
#% description: Output vector for result
#% required : yes
#%end
#%option
#% key: beamwidth
#% type: double
#% description: Beam width as a multiple of water depth
#% required : no
#% answer: 3
#%end
#%option
#% key: distance
#% type: double
#% description: Along track distance between swath width estimates
#% required : no
#% answer: 100
#%end

# Run g.parser
if [ "$1" != "@ARGS_PARSED@" ] ; then
  PARSER=`which g.parser`
  exec $PARSER "$0" "$@"
fi

# Save the region and then reduce the size of the region as much as
# possible to save raster processing time
g.remove region=temp_swath 2>&1 /dev/null
g.region save=temp_swath  2>&1 /dev/null
g.region vect=$GIS_OPT_TRACKLINE 2>&1 /dev/null

# Convert the raster elevation DEM into units of "swath widths"
r.mapcalc "temp_swath = if($GIS_OPT_ELEVATION < 0, -1 * $GIS_OPT_ELEVATION * $GIS_OPT_BEAMWIDTH, null())"

# Split the track line into segments where swath width will be visualized
v.to.points input=$GIS_OPT_TRACKLINE output=temp_point dmax=$GIS_OPT_DISTANCE --o 2>&1 /dev/null

# Add a column to hold the swath width values
v.db.addcol map=temp_point layer=2 columns="width double" 2>&1 /dev/null

# Load the swath width values into the table
v.what.rast vect=temp_point rast=temp_swath layer=2 col=width 2>&1 /dev/null

# To visualize the swath width, buffer the nodes of the trackline by swath width
v.buffer input=temp_point output=temp_circles type=point layer=2 bufcol=width --o 2>&1 /dev/null

# The output of v.buffer currently does not join together the areas of all of the buffer circles
# with a union command (I'm not sure what it is doing actually). The following code dissolves
# all of the little polygons created by v.buffer into as few shapes as possible (union of all 
# shapes). This section is basically written by Hamish via the mailing list. Thanks!

# Break polygons at intersections (flatten circles)
v.clean input=temp_circles out=temp_circles2 tool=break --o 2>&1 /dev/null

# Add centroids to each polygon to make areas
v.category input=temp_circles2 output=temp_circles3 step=0 --o 2>&1 /dev/null 

# Disolve common boundaries (union of areas)
v.extract -d type=area in=temp_circles3 out=temp_circles4 --o 2>&1 /dev/null

# Reset the region
g.region region=temp_swath 2>&1 /dev/null

# Clean up
g.rename vect=temp_circles4,$GIS_OPT_OUT --o
g.mremove -f vect=temp_* 2>&1 /dev/null
g.remove rast=temp_swath 2>&1 /dev/null

echo Swath width map written to: $GIS_OPT_OUT

# end
