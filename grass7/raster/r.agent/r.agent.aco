#!/usr/bin/env python
"""
MODULE:       r.agent.aco
AUTHOR(S):    michael lustenberger inofix.ch
PURPOSE:      r.agent.aco is used to organize ant-like agents in a raster
              based playground. As decribed by the Ant Colony Optimization
              algorithm, the ants wander around looking for attractors,
              marking their paths if they find any.
COPYRIGHT:    (C) 2011 by Michael Lustenberger and the GRASS Development Team

              This program is free software under the GNU General Public
              License (>=v2). Read the file COPYING that comes with GRASS
              for details.
"""

#%Module
#% description: Agents wander around on the terrain, marking paths to new locations.
#%End
#%option
#% key: outputmap
#% type: string
#% gisprompt: old,cell,raster
#% description: Name of pheromone output map
#% required : yes
#%end
#%option
#% key: inputmap
#% type: string
#% gisprompt: old,cell,raster
#% description: Name of input pheromone raster map (e.g. from prior run)
#% required : no
#%end
#%flag
#% key: p
#% description: Allow overwriting existing pheromone maps
#%end
#%flag
#% key: c
#% description: Overwrite existing cost map (only used with penalty conversion)
#%end
#%option
#% key: costmap
#% type: string
#% gisprompt: old,cell,raster
#% description: Name of penalty resp. cost raster map (note conversion checkbox)
#% required : yes
#%end
#%flag
#% key: convert
#% description: Convert cost (slope..) to penalty map (using "tobler", see docu)
#%end
#%option
#% key: sitesmap
#% type: string
#% gisprompt: old,vect,vector
#% description: Name of sites map, vector data with possible points of origin
#% required : yes
#%end
#%option
#% key: rounds
#% type: integer
#% gisprompt: number
#% description: Number of iterations/rounds to run
#% answer: 999
#% options: 0-999999
#% required : yes
#%end
#%option
#% key: outrounds
#% type: integer
#% gisprompt: number
#% description: Produce output after running this number of iterations/rounds
#% options: 0-999999
#% required : no
#%end
#%option
#TODO evaluate..
#% key: targetvisibility
#% type: integer
#% gisprompt: number
#% description: Distance to target from where it might be 'sensed'
#% options: 0-999999
#% required : no
#%end
#%option
#% key: highcostlimit
#% type: integer
#% gisprompt: number
#% description: Penalty values above this point an ant considers as illegal
#% options: 0-<max integer on system would make sense>
#% required : no
#%end
#%option                                                       
#% key: lowcostlimit
#% type: integer
#% gisprompt: number
#% description: Penalty values below this point an ant considers as illegal
#% options: <min integer on system would make sense>-0
#% required : no
#%end
#%option
#% key: maxpheromone
#% type: integer
#% gisprompt: number
#% description: Absolute maximum of pheromone intensity a position may have
#% options: <minpheromone>-<max integer on system would make sense>
#% required : no
#%end
#%option
#% key: minpheromone
#% type: integer
#% gisprompt: number
#% description: Absolute minimum of pheromone intensity to leave on playground
#% options: 0-<maxpheromone>
#% required : no
#%end
#%option
#% key: volatilizationtime
#% type: integer
#% gisprompt: number
#% description: Half-life for pheromone to volatize (e.g. =rounds)
#% options: 0-<max integer on system would make sense>
#% required : no
#%end
#%option
#% key: stepintensity
#% type: integer
#% gisprompt: number
#% description: Pheromone intensity to leave on each step
#% options: 0-<max integer on system would make sense>
#% required : no
#%end
#%option
#% key: pathintensity
#% type: integer
#% gisprompt: number
#% description: Pheromone intensity to leave on found paths
#% options: 0-<max integer on system would make sense>
#% required : no
#%end
#%option
#% key: maxants
#% type: integer
#% gisprompt: number
#% description: Maximum amount of ants that may live concurrently (x*y)
#% options: 0-<the bigger the playground, the more space they have>
#% required : no
#%end
#%option
#% key: antslife
#% type: integer
#% gisprompt: number
#% description: Time to live for an ant (e.g. four times points distance)
#% options: 0-<max integer on system would make sense>
#% required : no
#%end
#%option
#% key: decisionalgorithm
#% type: string
#% gisprompt: algorithm
#% description: Algorithm used for walking step
#% answer: standard
#% options: standard,random,test
#% required : yes
#%end
#%option
#% key: validposition
#% type: string
#% gisprompt: algorithm
#% description: Algorithm used for finding and remembering paths
#% answer: avoidorforgetloop
#% options: specials,avoidloop,forgetloop,avoidorforgetloop
#% required : yes
#%end
#%option
#% key: agentfreedom
#% type: integer
#% gisprompt: number
#% description: Number of possible directions the ant can take (4 or 8)
#% options: 4,8
#% required : no
#%end
#%option
#% key: pheromoneweight
#% type: integer
#% gisprompt: number
#% description: How is the pheromone value (P) weighted when walking (p*P:r*R:c*C)
#% answer: 1
#% options: 0-999
#% required : yes
#%end
#%option
#% key: randomnessweight
#% type: integer
#% gisprompt: number
#% description: How is the random value (R) weighted when walking (p*P:r*R:c*C)
#% answer: 1
#% options: 0-999
#% required : yes
#%end
#%option
#% key: costweight
#% type: integer
#% gisprompt: number
#% description: How is the penalty value (C) weighted when walking (p*P:r*R:c*C)
#% answer: 0
#% options: 0-999
#% required : yes
#%end

from sys  import exit, maxsize
from math import sqrt
from math import exp
from random import randint

from libagent import error, grassland, anthill

try:
    from grass.script import core as grass
except ImportError:
    raise error.EnvError("r.agent.aco:", "Please run inside GRASS.")

world = anthill.Anthill(grassland.Grassland())

def setmaps(site, cost, wastecosts, inphero, outphero, wastephero):
    """
    Set the user maps in place
    """
    if site:
        # set sitemap and site list
        world.sites = world.playground.parsevectorlayer(anthill.Anthill.SITE,
                                                        site, True)
    else:
        raise error.DataError("aco:", "The site map is mandatory.")
    if cost:
        # set cost/penalty layer
        world.playground.setgrasslayer(anthill.Anthill.COST, cost, True)
        world.overwritepenalty = wastecosts
    if inphero == outphero:
        if not wastephero:
            raise error.DataError("aco:", "May not overwrite the output map.")
    if inphero:
        world.playground.setgrasslayer(anthill.Anthill.RESULT, inphero, True)
    world.playground.grassmapnames[anthill.Anthill.RESULT] = outphero
    world.overwritepheormone = wastephero

def letantsdance(rounds, outrounds):
    """
    Organize the agents and the pheromone on the playground.
    """
    if 0 < outrounds < rounds:
        # calculate when to write output
        mainloops = rounds / outrounds
        nextwrite = outrounds
    else:
        # produce output only at the end
        mainloops = 1
        nextwrite = rounds
    while mainloops > 0:
        # loop and write out the contents at the end
        loops = nextwrite
        while loops > 0:
            # loop without producing output
            if len(world.agents) < world.maxants:
                # as there is still space on the pg, produce another ant
                # at a random site..
                position = world.sites[randint(0, len(world.sites)-1)]
                world.bear(world.antslife, position)
            for ant in world.agents:
                # let all the ants take action
                ant.walk()
            # let the pheromone evaporate
            world.volatilize()
            # count down inner
            loops -= 1
        # export the value maps
        world.writeout()
#        print "nrofpaths:", world.nrop
        # count down outer
        mainloops -= 1
#    print "nrofrounds", nrofrounds

def main():

    setmaps(options['sitesmap'],
            options['costmap'], flags['c'],
            options['inputmap'], options['outputmap'], flags['p'])

#    world.playground.setboundsfromlayer("costs")

    if options['maxpheromone']:
        world.maxpheromone = int(options['maxpheromone'])
    if options['minpheromone']:
        world.minpheromone = int(options['minpheromone'])
    if options['volatilizationtime']:
        world.volatilizationtime = int(options['volatilizationtime'])
    if options['stepintensity']:
        world.stepintensity = int(options['stepintensity'])
    if options['pathintensity']:
        world.pathintensity = int(options['pathintensity'])
    if options['maxants']:
        world.maxants = int(options['maxants'])
    if options['antslife']:
        world.antslife = int(options['antslife'])
#    if options['decisionalgorithm']:
#        world.decisionbase = str(options['decisionalgorithm'])
#    if options['validposition']:
#        world.validposition = str(options['validposition'])
#    if options['agentfreedom']:
#        world.globalfreedom = int(options['agentfreedom'])
    if options['pheromoneweight']:
        world.pheroweight = int(options['pheromoneweight'])
    if options['randomnessweight']:
        world.randomweight = int(options['randomnessweight'])
    if options['costweight']:
        world.costweight = int(options['costweight'])
    #if arglist[0] == "stability":
        #TODO ask silvia..
    try:
#        world.checkvalues()
        if not options['outrounds']:
            options['outrounds'] = 0
#        letantsdance(int(options['rounds']), int(options['outrounds']))
        grass.message("FINISH")
    except error.DataError:
        grass.fatal_error("Failed to parse args..")
        sys.exit(1)

if __name__ == "__main__":
    options, flags = grass.parser()
    main()

