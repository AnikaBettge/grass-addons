<h2>DESCRIPTION</h2>

<em>r.agent</em> shall provide an inital base for organizing worlds
with raster playgrounds and agents in.
<p>
As this is only a first implementation the encapsulation that grants
a modular usage is still suffering..
<p>
<em>r.agent</em> is written in python for more transparency and
better extendability.
<p>
As a first world example there is an ACO-based
environement
(see <a href="http://en.wikipedia.org/wiki/Ant_colony_optimization_algorithms">Ant Colony Optimization</a>)
available.
<p>
The basic concept of such an ACO world, is to take some cost surface
and transform it to a penalty layer - where for human ants for example
this penalty layer may be expressed by the walking velocity, e.g. calculated
with the algorithm proposed by
<a href="http://www.geodyssey.com/papers/tobler93.html">Tobler1993</a>.
The actors on the playground will wander around on the playground
using the time for their paths that correspond with the values in the penalty
grid.
If they find some attractor, they walk home to the position they
originated, marking their way with pheromones. While this
pheromone vanishes over time, the following agents are more likely
to choose their next steps to a position that smells most.

<p>
This toolset was partly developed at the
<a href="http://www.topoi.org/">Topoi / FU Berlin</a> with
inspirations from previous work conducted at the
<a href="http://www.unibe.ch//">Uni Bern</a>.


<h2>NOTES</h2>

The state of this software is: "first do it".
This is work in progress and its structure will probably change quite a lot
in the future due to a better integration in GRASS and other refactoring.
<p>
Unfortunately this script colletion is not very well included in GRASS yet.
At the moment <em>r.agent</em> only handles ASCII grid and vector in- and
output data. With a better GRASS integration not only will the code
get lighter but also this drawbacks shall vanish.
<p>
ACO works best on dynamic maps -- it constantly tries to improve paths...


<h2>EXAMPLE</h2>

A fictive usecase could look something like this:
<p>
# ./r.agent.aco output=out.map costraster=penalty.grid vectorholes=sites.vect rounds=10 outputrounds=10 volatilizationtime=5000 antslife=2000 maxants=400 pathintensity=1000000
<p>
For running the total test suite on the libraries,
i.e. to run all the tests that are at the end
of each python file, use this test collection
(for certain tests, the following files must exist though:
 "elev.grid", and "arch.vect"):
<p>
# cd library
<p>
# ./alltests.py


<h2>TODO</h2>

Add GRASS headers (?).
<p>
Cleanup.
<p>
Integrate it directly within grass.
<p>
Improve encapsulation of classes.
<p>
Find good parameters, or parameter finding strategies for the ACO part.
Try to avoid high penalty fields.
Think about heuristics too.
<p>
Implement other ABM scenarios.


<h2>SEE ALSO</h2>

<h2>AUTHORS</h2>

Michael Lustenberger inofix.ch

<p><i>Last changed: $Date$</i>


