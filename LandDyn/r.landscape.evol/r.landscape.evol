#!/bin/sh
#
############################################################################
#
# MODULE:          r.landscape.evol
# AUTHOR(S):	   Isaac Ullah, Michael Barton, Arizona State University
#		   Helena Mitasova, North Carolina State University
# PURPOSE:	   Create raster maps of net erosion/depostion, the modified terrain surface (DEM) after net
#		   erosion/deposition using the USPED equation, bedrock elevations after soil production, and soil 
#                  depth maps.  This module uses appropriate flow on different landforms by default; however, 
#                  singular flow regimes can be chosen instead.
# ACKNOWLEDGEMENTS:National Science Foundation Grant #BCS0410269 
#		   Based on work of H. Mitasova and C. S. Thaxton, and Heimsath et al, 1997.
# COPYRIGHT:	   (C) 2009 by Isaac Ullah, Michael Barton, Arizona State University
#		   This program is free software under the GNU General Public
#		   License (>=v2). Read the file COPYING that comes with GRASS
#		   for details.
#
#############################################################################


#%Module
#%  description: Create raster maps of net erosion/depostion, the modified terrain surface (DEM) after net erosion/deposition using the USPED equation, bedrock elevations after soil production, and soil depth maps. This module uses appropriate flow on different landforms by default; however, singular flow regimes can be chosen instead. THIS SCRIPT WILL PRODUCE MANY TEMPORARY MAPS AND REQUIRES A LOT OF FREE FILE SPACE!
#%End

#%option
#% key: elev
#% type: string
#% gisprompt: old,cell,raster
#% description: Input elevation map (DEM)
#% required : yes
#% guisection: Input
#%end
#%option
#% key: initbdrk
#% type: string
#% gisprompt: old,cell,raster
#% description: Initial bedrock elevations map (for first iteration only)
#% answer: 
#% required : yes
#% guisection: Input
#%end
#%option
#% key: prefx
#% type: string
#% description: Prefix for all output maps
#% answer: levol_
#% required : yes
#% guisection: Input
#%end
#%option
#% key: outdem
#% type: string
#% gisprompt: string
#% description: Name stem for output elevation map(s) (preceded by prefix and followed by numerical suffix if more than one iteration)
#% answer: elevation
#% required: yes
#% guisection: Input
#%end
#%option
#% key: outsoil
#% type: string
#% gisprompt: string
#% description: Name stem for the output soil depth map(s) (preceded by prefix and followed by numerical suffix if more than one iteration)
#% answer: soildepth
#% required: yes
#% guisection: Input
#%end
#%option
#% key: outbdrk
#% type: string
#% gisprompt: string
#% description: Name stem for the output bedrock map(s) (required if the -b option is NOT checked; preceded by prefix and followed by numerical suffix if more than one iteration)
#% answer: bedrock
#% required: no
#% guisection: Input
#%end
#%Option
#% key: statsout
#% type: string
#% gisprompt: string
#% description: Name for the statsout text file (optional, if none provided, a default name will be used)
#% required: no
#% guisection: Input
#%end
#%flag
#% key: g
#% description: -g do not put header on statsout text file and always append data, even if file already exists (useful if script is being run by an outside program)
#% guisection: Input
#%end
#%flag
#% key: l
#% description: -l Do not output maps of soil depths
#% guisection: Input
#%end
#%flag
#% key: k
#% description: -k Keep all intermediate files as well
#% guisection: Input
#%end
#%flag
#% key: e
#% description: -e Keep initial soil depths map
#% guisection: Input
#%end
#%flag
#% key: z
#% description: -z Keep region zoomed to output maps 
#% answer: 1
#% guisection: Input
#%end
#%flag
#% key: b
#% description: -b Use static bedrock elavations (do not create new soil) 
#% answer: 1
#% guisection: Input
#%end


#%option
#% key: R
#% type: string
#% description: Rainfall (R factor) constant (AVERAGE FOR WHOLE MAP AREA)
#% answer: 5.66
#% required : yes
#% guisection: Variables
#%end
#%option
#% key: K
#% type: string
#% gisprompt: old,cell,raster
#% description: Soil erodability index (K factor) map or constant
#% answer: 0.42
#% required : yes
#% guisection: Variables
#%end
#%option
#% key: sdensity
#% type: string
#% gisprompt: old,cell,raster
#% description: Soil density constant (for conversion from mass to volume)
#% answer: 1.2184
#% required : yes
#% guisection: Variables
#%end
#%option
#% key: C
#% type: string
#% gisprompt: old,cell,raster
#% description: Landcover index (C factor) map or constant
#% answer: 0.001
#% required : yes
#% guisection: Variables
#%end
#%option
#% key: kappa
#% type: string
#% gisprompt: old,cell,raster
#% description: Hillslope diffusion (Kappa) rate map or constant (meters per kiloyear)
#% answer: 1
#% required : yes
#% guisection: Variables
#%end
#%option
#% key: cutoff1
#% type: string
#% description: Flow accumultion breakpoint value for shift from diffusion to overland flow (number of cells)
#% answer: 4
#% required : yes
#% guisection: Variables
#%end
#%option
#% key: cutoff2
#% type: string
#% description: Flow accumultion breakpoint value for shift from overland flow to channelized flow (number of cells)
#% answer: 50
#% required : yes
#% guisection: Variables
#%end
#%option
#% key: number
#% type: integer
#% description: number of iterations (cycles) to run
#% answer: 1
#% required : yes
#% guisection: Variables
#%end


#these are commented out as we currently utilize the profile curvature method described by Heimsath et al...
# 	#%option
# 	#% key: Ba
# 	#% type: string
# 	#% description: Rate of average soil production (Ba)
# 	#% answer: 0.00008
# 	#% required : yes
# 	#% guisection: Variables
# 	#%end
# 	#%option
# 	#% key: Bb
# 	#% type: string
# 	#% description: Relationship between soil depth and production rate (Bb)
# 	#% answer: 0.1
# 	#% required : yes
# 	#% guisection: Variables
# 	#%end

#%flag
#% key: y
#% description: -y Smooth the map every year (Uesful if artifacts appear on unsmoothed output maps)
#% guisection: Smoothing_Filter
#%end
#%option
#% key: nbhood
#% type: string
#% description: Band-pass filter neighborhood size
#% answer: 3
#% options: 1,3,5,7,9,11,13,15,17,19,21,23,25
#% required : yes
#% guisection: Smoothing_Filter
#%end
#%option
#% key: method
#% type: string
#% description: Neighborhood smoothing method
#% answer: median
#% options: average,median,mode
#% required : yes
#% guisection: Smoothing_Filter
#%end

#%flag
#% key: n
#% description: -n Output maps of net elevation change for every cycle
#% answer: 1
#% guisection: Statistics
#%end
#%flag
#% key: c
#% description: -c Output cumulative erosion/deposition map from data for all iterations
#% guisection: Statistics
#%end
#%flag
#% key: m
#% description: -m Output mean erosion/depostition map from data for all iterations (must check -n as well)
#% guisection: Statistics
#%end
#%flag
#% key: t
#% description: -t Output standard deviation of erosion/depostition map from data for all iterations (must check -n as well)
#% guisection: Statistics
#%end
#%flag
#% key: s
#% description: -s Output mean soil depths map from data for all iterations
#% guisection: Statistics
#%end
#%flag
#% key: v
#% description: -v Output standard deviation soil depths map from data for all iterations
#% guisection: Statistics
#%end
#%flag
#% key: a
#% description: -a Output maximum soil depths map from data for all iterations
#% guisection: Statistics
#%end
#%flag
#% key: u
#% description: -u Output minimum soil depths map from data for all iterations
#% guisection: Statistics
#%end

#%flag
#% key: w
#% description: -w Calcuate for only sheetwash across entire map
#% guisection: Flow_type
#%end
#%flag
#% key: r
#% description: -r Calcuate for only channelized flow across entire map
#% guisection: Flow_type
#%end
#%flag
#% key: d
#% description: -d Calcuate for only diffusive flow (soil creep) across entire map
#% guisection: Flow_type
#%end
#%flag
#% key: f
#% description: -f Use r.terrflow instead of r.watershed to calculate flow accumulation ( GRASS 6.3.x users MUST use this flag!)
#% answer: 0
#% guisection: Flow_type
#%end



if  [ -z "$GISBASE" ] ; then
 echo "You must be in GRASS GIS to run this program." >&2
 exit 1
fi

if [ "$1" != "@ARGS_PARSED@" ] ; then
  exec g.parser "$0" "$@"
fi

prefx=$GIS_OPT_prefx
elev=$GIS_OPT_elev
initbdrk=$GIS_OPT_initbdrk
outbdrk=$GIS_OPT_outbdrk
outdem=$GIS_OPT_outdem
outsoil=$GIS_OPT_outsoil
R=$GIS_OPT_R
K=$GIS_OPT_K
sdensity=$GIS_OPT_sdensity
C=$GIS_OPT_C
kappa=$GIS_OPT_kappa
Ba=$GIS_OPT_Ba
Bb=$GIS_OPT_Bb
aplpha=$GIS_OPT_method
sigma=$GIS_OPT_sigma
nbhood=$GIS_OPT_nbhood
cutoff1=$GIS_OPT_cutoff1
cutoff2=$GIS_OPT_cutoff2
num_iters=$GIS_OPT_number
echo "total number of iterations to be run= $num_iters"
echo ""

#let's grab the current resolution
res1=`eval g.region -p -m | grep "nsres:" | cut -d : -f 2`

# we must set the region to the map being used. otherwise r.flow will not work
echo ""
echo "Setting region to $elev"
g.region -a rast=$elev

#now lets show before:
echo ""
echo "Original Resolution = $res1"

#...and after:
res=`eval g.region -p -m | grep "nsres:" | cut -d : -f 2`
echo ""
echo "New Resolution = $res"
echo ""

# each iteration through the loop represents 1 simulation cycle
echo ""
echo "##################################################"
echo "##################################################"
echo ""
echo "STARTING SIMULATION"
echo ""
echo "Beginning iteration sequence. This may take some time."
echo "Process is not finished until you see the message: 'Done with everything' "
echo "_____________________________________________________________"
echo "_____________________________________________________________"
echo ""

iter="0"
while [ "$iter" -lt "$num_iters" ]
do
	last_iter=$iter
	iter=$(($iter+1)) 		# loop iteration control

	echo ""
	echo "ITERATION $iter OF $num_iters"
	echo ""
	echo "****************************"
	echo ""
	echo "The following temporary files will be created:"
	echo ""
	tempsmoothdz=$prefx"tempsmoothdz"$iter
	echo "tempsmoothdz=$tempsmoothdz"
	tempsmoothdz=$prefx"tempsmoothdz"$iter
	echo "temsmoothpdz=$tempsmoothdz"
	flowacc=$prefx"flowacc"$iter
	echo "flowacc=$flowacc"
	slope=$prefx"slope"$iter
	echo "slope=$slope"
	aspect=$prefx"aspect"$iter
	echo "aspect=$aspect"
	pc=$prefx"pc"$iter
	echo "pc=$pc"
	tc=$prefx"tc"$iter
	echo "tc=$tc"
	meancurv=$prefx"meancurv"$iter
	echo "meancurv=$meancurv"
	rate=$prefx"rate"$iter
	echo "rate=$rate"
	sflowtopo=$prefx"sflowtopo"$iter
	echo "sflowtopo=$sflowtopo"
	qsx=$prefx"qsx"$iter
	echo "qsx=$qsx"
	qsy=$prefx"qsy"$iter
	echo "qsy=$qsy"
	qsxdx=$prefx"qsx_dx"$iter
	echo "qsxdx=$qsxdx"
	qsydy=$prefx"qsy_dy"$iter
	echo "qsydy=$qsydy"
	m=$prefx"mexp"$iter
	echo "m=$m"
	n=$prefx"nexp"$iter
	echo "n=$n"
	erdep=$prefx"erosdep"$iter
	echo "erdep=$erdep"
	echo ""

	# if first iteration, use input maps. Otherwise, use maps generated from previous iterations
	if [ "$iter" -eq 1 ]; then
	  old_dem=$elev
	  old_bdrk=$initbdrk
	  old_soil=$prefx$outsoil"_init"
	  r.mapcalc "$old_soil=$elev - $old_bdrk"

	  #stats output file
	  mapset=`eval g.gisenv get=MAPSET`
	  txtout=$mapset$prefx"erdep_stats.txt"

	  # create temporary file to code colors for $netchange
	  TMP1=`g.tempfile pid=$$`
	  if [ $? -ne 0 ] || [ -z "$TMP1" ] ; then
	    echo "ERROR: unable to create temporary file for netchange colors" 1>&2
	    exit 1
	  fi

	  echo "100% 0 0 100" > $TMP1
	  echo "1 blue" >> $TMP1
	  echo "0.5 indigo" >> $TMP1
	  echo "0.01 green" >> $TMP1
	  echo "0 white" >> $TMP1
	  echo "-0.01 yellow" >> $TMP1
	  echo "-0.5 orange" >> $TMP1
	  echo "-1 red" >> $TMP1
	  echo "0% 150 0 50" >> $TMP1

	  # create temporary file to code colors for $soildepth
	  TMP4=`g.tempfile pid=$$`
	  if [ $? -ne 0 ] || [ -z "$TMP4" ] ; then
    	    echo "ERROR: unable to create temporary file for soil colors" 1>&2
    	    exit 1
	  fi

	  echo "100% 0 0 100" > $TMP4
	  echo "10 blue" >> $TMP4
	  echo "5 indigo" >> $TMP4
	  echo "1 green" >> $TMP4
	  echo "0.1 yellow" >> $TMP4
	  echo "0.03 orange" >> $TMP4
	  echo "0.01 red" >> $TMP4
	  echo "0.001 150 0 50" >> $TMP4
	  echo "0 white" >> $TMP4
	else
	  old_dem=$prefx$outdem$last_iter
	  old_bdrk=$prefx$outbdrk$last_iter
	  old_soil=$prefx$outsoil$last_iter
	  lastsmooth=$prefx"smoothdz"$last_iter
	fi

	echo "old_dem=$old_dem"
	echo "old_bdrk=$old_bdrk"
	echo "old_soil=$old_soil"
	echo ""
	if [ $num_iters -ne 1 ]; then
		smoothdz=$prefx"smoothdz"$iter
		netchange=$prefx"netchange"$iter
		new_dem=$prefx$outdem$iter
		new_bdrk=$prefx$outbdrk$iter
		new_soil=$prefx$outsoil$iter
	else
		smoothdz=$prefx"smoothdz"
		netchange=$prefx"netchange"
		new_dem=$prefx$outdem
		new_bdrk=$prefx$outbdrk
		new_soil=$prefx$outsoil
	fi
	
	echo "The new net erosion/deposition map for this iteration will be called  $netchange"
	echo "The new dem for this iteration will be called  $new_dem"
	echo "The new soil depth map for this iteration will be called  $new_soil"
	
	if [ "$GIS_FLAG_b" -eq 1 ]; then
	  echo ""	
	else
	  echo "The new bedrock elevation map for this iteration will be called  $new_bdrk"
	fi

	echo ""
	echo "##################################################"
	echo ""
	echo "*************************"
	echo "step 1 of 8: calculating slope and aspect (if initial aspect not specified)"
	echo "*************************"
	echo ""

	r.slope.aspect --quiet elevation=$old_dem slope=$slope aspect=$aspect pcurv=$pc tcurv=$tc


	echo ""
	echo "*************************"
	echo "step 2 of 8: calculating upslope accumulated flow"
	echo "*************************"
	echo ""
	#First we need to grab the amount of free RAM for r.terraflow
	mem=`eval free -mo  | grep "Mem" | tr -s /[:blank:] /[:] | cut -d":" -f4`
	
	if [ "$GIS_FLAG_f" -eq 1 ]; then
	  echo "using r.terraflow to calculate overland flow accumulation per cell (number of cells uplsope from each cell)"
	  echo ""

	  #r.terraflow can't handle it if you tell it to use more than 2 Gigs of RAM, so if you have more than that, we have to tell r.terraflow to only use up to 2 Gigs of the free RAM... 

	  if [ "$mem" -lt "2000" ]; then
	    mem=$mem
	  else
	    mem="2000"
	  fi

	  echo "Amount of free RAM being allocated for this step: $mem Megabites"

	  tmpflacc=$prefx".tmpflacc"

	  r.terraflow --q elev=$old_dem filled=$prefx".filled" direction=$prefx".direct" swatershed=$prefx".sink" accumulation=$tmpflacc tci=$prefx".tci" d8cut=infinity memory=$mem STREAM_DIR=/var/tmp 

	  #changing raw flow accumulation map to number of square meters of upslope contributing area
	  r.mapcalc "$flowacc=$tmpflacc*exp($res, 2)"

	  g.remove --quiet rast=$prefx".filled",$prefx".direct",$prefx".sink",$prefx".tci",$tmpflacc,$tmpdirection

	  rm -f /var/tmp/STREAM*

	else
	  echo "using r.watershed to calculate overland flow accumulation per cell (number of cells uplsope from each cell)"

	  tmpflacc=$prefx"tmpflacc"

	  r.watershed --quiet elevation=$old_dem visual=$tmpflacc memory=$mem
	  
	  #cchanging raw flow accumulation map to number of square meters of upslope contributing area
	  r.mapcalc "$flowacc=$tmpflacc*exp($res, 2)"

	  g.remove --quiet rast=$tmpflacc
	fi

	echo ""
	echo "*************************"
	echo "step 3 of 8: calculating basic sediment transport rates"
	echo "*************************"
	echo ""

	if [ "$GIS_FLAG_w" -eq 1 -a "$GIS_FLAG_d" -eq 0 -a "$GIS_FLAG_r" -eq 0 ]; then
	  echo "" 
	  echo	"calculating for sheetwash across the entire map"
	  r.mapcalc "$sflowtopo=$flowacc * sin($slope)"
	elif [ "$GIS_FLAG_r" -eq 1 -a "$GIS_FLAG_d" -eq 0 -a "$GIS_FLAG_w" -eq 0 ]; then
	  echo ""
	  echo	"calculating for channelzed flow across the entire map"

	  r.mapcalc "$sflowtopo=exp(($flowacc),1.6) * exp(sin($slope),1.3)"

	elif [ "$GIS_FLAG_d" -eq 1 -a "$GIS_FLAG_r" -eq 0 -a "$GIS_FLAG_w" -eq 0 ]; then
	  echo "" 
	  echo	"calculating for diffusive flow across the entire map"

	  r.mapcalc "$sflowtopo=$kappa * exp(($res),2) * sin($slope)"

	elif [ "$GIS_FLAG_d" -eq 1 -a "$GIS_FLAG_r" -eq 1 -a "$GIS_FLAG_w" -eq 0 ]; then
	  echo ""
	  echo "############################################################"
	  echo "!!!!!!!!!YOU MUST SELECT ONLY ONE TYPE OF EROSION!!!!!!!!!!!"
	  echo "############################################################"
	  echo ""

	elif [ "$GIS_FLAG_d" -eq 0 -a "$GIS_FLAG_r" -eq 1 -a "$GIS_FLAG_w" -eq 1 ]; then
	  echo ""
	  echo "############################################################"
	  echo "!!!!!!!!!YOU MUST SELECT ONLY ONE TYPE OF EROSION!!!!!!!!!!!"
	  echo "############################################################"
	  echo ""

	elif [ "$GIS_FLAG_d" -eq 1 -a "$GIS_FLAG_r" -eq 0 -a "$GIS_FLAG_w" -eq 1 ]; then
	  echo ""
	  echo "############################################################"
	  echo "!!!!!!!!!YOU MUST SELECT ONLY ONE TYPE OF EROSION!!!!!!!!!!!"
	  echo "############################################################"
	  echo ""

	elif [ "$GIS_FLAG_d" -eq 1 -a "$GIS_FLAG_r" -eq 1 -a "$GIS_FLAG_w" -eq 1 ]; then
	  echo ""
	  echo "############################################################"
	  echo "!!!!!!!!!YOU MUST SELECT ONLY ONE TYPE OF EROSION!!!!!!!!!!!"
	  echo "############################################################"
	  echo ""

	else
	  maxflow=`eval r.info -r map=$flowacc  | grep "max=" | cut -d"=" -f2`

	  echo ""
	  echo "The raw max ($maxflow) flow accumulation, min cutoff $cutoff1, and middle cutoff $cutoff2 will be used to scale flow exponents 'm' and 'n' as flow progresses in the drainage network"
	  echo ""
	  echo "" 
	  echo "calculating with appropriate flow types on different landforms"

	  r.mapcalc "$m=if($flowacc > $cutoff2, 1.6, if($flowacc > $cutoff1 && $flowacc < $cutoff2, (1+($flowacc * (0.6/($cutoff2 - $cutoff1)))), 1))"

	  r.mapcalc "$n=if($flowacc > $cutoff2,1.3, if($flowacc > $cutoff1 && $flowacc < $cutoff2, (1+($flowacc * (0.3/($cutoff2 - $cutoff1)))), 1))"

	  r.mapcalc "$sflowtopo=if ($flowacc >= $cutoff1, exp(($flowacc),$m) * exp(sin($slope),$n),  ($kappa * exp(($res),2) *sin($slope)))"
	fi

	echo ""
	echo "*************************"
	echo "step 4 of 8: calculating sediment transport capacity in x and y directions"
	echo "*************************"
	echo ""

	#if the old soil is 0 or negative(could happen i suppose) then we make k-factor really really small to simulate erosion on bedrock
	r.mapcalc "$qsx=if ($old_soil <= 0, ($R * 0.001 * $C * $sflowtopo * cos($aspect)), ($R * $K * $C * $sflowtopo * cos($aspect)))"
	r.mapcalc "$qsy=if ($old_soil <= 0, ($R * 0.001 * $C * $sflowtopo * sin($aspect)), ($R * $K * $C * $sflowtopo * sin($aspect)))"

	echo ""
	echo "*************************"
	echo "step 5 of 8: calculating partial derivatives for sediment transport"
	echo "*************************"
	echo ""

	r.slope.aspect --q $qsx dx=$qsxdx
	r.slope.aspect --q $qsy dy=$qsydy

	echo ""
	echo "*************************"
	echo "step 6 of 8: calculating net erosion and deposition"
	echo "*************************"
	echo ""

	#Here we add the x and y flux's for total flux "T" in Mg/Ha. Then if we multiply T times 100, we get a rate in grams/squaremeter. This new rate times the resolution gives us grams per cell width. Then we divide this by the density to get cubic centimeters per cell width. This measure is then divided by the area of the cell in centimeters (resolution squared x 100 squared) to get vertical change per cell width in centimeters. We dived this by 100 to get that measure in meters. Several of these facctors cancel out to make a final equation of "T/(10,000*density*resolution)". This equation changes the orignal T from Mg/Ha to vertical change in meters over the length of one cell's width.  In order to convert the output back to Mg/Ha (standard rate for USPED/RUSLE equations), you can multiply the netchange output map by "(10000 x resolution x soil density)" to create a map of soil erosion/deposition rates across the landscape. The rest of this mampcalc statement just checks the amount of erodable soil in a given cell against the amount of erosion calculated, and keeps the cell from eroding past this amount (if there is soil, then if the amount of erosion is more than the amount of soil, just remove all the soil and stop, else remove the amount of caclulated erosion. It also runs an error catch that checks to make sure that soil depth is not negative, and if it is, corrects it).
	r.mapcalc "$erdep=if( $old_soil >= 0, if( (-1 * ( ($qsxdx + $qsydy) / ( 10000 * $sdensity * $res ) ) ) >= $old_soil, ( -1 * $old_soil ), ( ($qsxdx + $qsydy) / ( 10000 * $sdensity * $res ) ) ), ( ($qsxdx + $qsydy) / ( 10000 * $sdensity * $res ) ) )"


	if [ "$GIS_FLAG_y" -eq 1 ]; then
	  echo "You have selected to smooth your files. Running bandpass despeckling filter now"
	  echo ""
	   r.neighbors --q input=$erdep output=$tempsmoothdz method=$GIS_OPT_method size=$GIS_OPT_nbhood


	else
	   tempsmoothdz=$erdep

	fi  

	 #now we must correct for the incredible edge shrinking effect by patching the last smoothdz underneath the new smoothdz
	 if [ $iter -ne 1 ]; then
	    r.patch input=$tempsmoothdz,$lastsmooth output=$smoothdz
	    g.remove --quiet rast=$tempsmoothdz
	 else
	    g.rename --quiet rast=$tempsmoothdz,$smoothdz
	 fi
	

	echo ""
	echo "*************************"
	echo "step 7 of 7: calculating terrain evolution, new bedrock elevations, and new soil depths"
	echo "*************************"
	echo ""


	if [ $iter -eq 1 ]; then
	  temp_dem=$prefx"temp_dem"
	elif [ $modulus -eq 0 ]; then
	  temp_dem=$prefx"temp_dem"
	else
	  temp_dem=$new_dem
	fi

	#put the net dz back where it is supposed to go and then subtract it from dem to make new dem
	if [ "$GIS_FLAG_f" -eq 1 ]; then
	
		r.mapcalc "$temp_dem=eval(x=if(($aspect < 22.5 ||  $aspect >= 337.5) && $aspect != 0, ($old_dem + $smoothdz[1,0]), if ($aspect >= 22.5 && $aspect < 67.5, ($old_dem + $smoothdz[1,-1]), if ($aspect >= 67.5 && $aspect < 112.5, ($old_dem + $smoothdz[0,-1]), if ($aspect >= 112.5 && $aspect < 157.5, ($old_dem + $smoothdz[-1,-1]), if ($aspect >= 157.5 && $aspect < 202.5, ($old_dem + $smoothdz[-1,0]), if ($aspect >= 202.5 && $aspect < 247.5, ($old_dem + $smoothdz[-1,1]), if ($aspect >= 247.5 && $aspect < 292.5, ($old_dem + $smoothdz[0,1]), if ($aspect >= 292.5 && $aspect < 337.5, ($old_dem + $smoothdz[1,1]), ($old_dem + $smoothdz))))))))), (if(isnull(x), $old_dem, if(x > ($old_dem + 5), ($old_dem + 1), x))))"
	
	else
	
		r.mapcalc "$temp_dem=eval(x=if(($aspect < 22.5 ||  $aspect >= 337.5) && $aspect != 0, ($old_dem + $smoothdz[1,0]), if ($aspect >= 22.5 && $aspect < 67.5, ($old_dem + $smoothdz[1,-1]), if ($aspect >= 67.5 && $aspect < 112.5, ($old_dem + $smoothdz[0,-1]), if ($aspect >= 112.5 && $aspect < 157.5, ($old_dem + $smoothdz[-1,-1]), if ($aspect >= 157.5 && $aspect < 202.5, ($old_dem + $smoothdz[-1,0]), if ($aspect >= 202.5 && $aspect < 247.5, ($old_dem + $smoothdz[-1,1]), if ($aspect >= 247.5 && $aspect < 292.5, ($old_dem + $smoothdz[0,1]), if ($aspect >= 292.5 && $aspect < 337.5, ($old_dem + $smoothdz[1,1]), ($old_dem + $smoothdz))))))))), (if(isnull(x), $old_dem, x)))"
	
	fi


	#set colors for maps
 	r.colors --q map=$temp_dem rast=$elev
	#do patch-job for year one to catch the shrinking edge problem
	if [ $iter -eq 1 ] ; then
	  r.patch --quiet input=$temp_dem,$old_dem output=$new_dem
	  g.remove --quiet rast=$temp_dem
	fi


	#make $netchange if asked
	if [ "$GIS_FLAG_n" -eq 1 -o "$GIS_FLAG_m" -eq 1 -o "$GIS_FLAG_t" -eq 1 -a "$GIS_FLAG_f" -eq 1 ]; then
	
		r.mapcalc "$netchange=eval(x=if(($aspect < 22.5 ||  $aspect >= 337.5) && $aspect != 0, ($smoothdz[1,0]), if ($aspect >= 22.5 && $aspect < 67.5, ($smoothdz[1,-1]), if ($aspect >= 67.5 && $aspect < 112.5, ($smoothdz[0,-1]), if ($aspect >= 112.5 && $aspect < 157.5, ($smoothdz[-1,-1]), if ($aspect >= 157.5 && $aspect < 202.5, ($smoothdz[-1,0]), if ($aspect >= 202.5 && $aspect < 247.5, ($smoothdz[-1,1]), if ($aspect >= 247.5 && $aspect < 292.5, ($smoothdz[0,1]), if ($aspect >= 292.5 && $aspect < 337.5, ($smoothdz[1,1]), ($smoothdz))))))))), (if(isnull(x), $smoothdz, if(x > 5, 1, x))))"
	
		#set colors for maps
		r.colors --quiet  map=$netchange rules=$TMP1

	elif [ "$GIS_FLAG_n" -eq 1 -o "$GIS_FLAG_m" -eq 1 -o "$GIS_FLAG_t" -eq 1 -a "$GIS_FLAG_f" -eq 0 ]
	then
	
		r.mapcalc "$netchange=eval(x=if(($aspect < 22.5 ||  $aspect >= 337.5) && $aspect != 0, ($smoothdz[1,0]), if ($aspect >= 22.5 && $aspect < 67.5, ($smoothdz[1,-1]), if ($aspect >= 67.5 && $aspect < 112.5, ($smoothdz[0,-1]), if ($aspect >= 112.5 && $aspect < 157.5, ($smoothdz[-1,-1]), if ($aspect >= 157.5 && $aspect < 202.5, ($smoothdz[-1,0]), if ($aspect >= 202.5 && $aspect < 247.5, ($smoothdz[-1,1]), if ($aspect >= 247.5 && $aspect < 292.5, ($smoothdz[0,1]), if ($aspect >= 292.5 && $aspect < 337.5, ($smoothdz[1,1]), ($smoothdz))))))))), (if(isnull(x), $smoothdz, x)))"

		#set colors for maps
		r.colors --quiet  map=$netchange rules=$TMP1

	fi

 
	if [ $GIS_FLAG_b -eq 1 ]; then
	  echo ""
	  echo "Calculating new soil depths keeping bedrock elevations static"

	  r.mapcalc "$new_soil=if (($new_dem - $initbdrk) < 0, 0, ($new_dem - $initbdrk))"
	else
	  echo ""
	  echo "step 8.5: Calculating new soil depths from landscape curvature"

	  r.mapcalc "$meancurv=(($pc + $tc) / 2)"

	  # create temporary file to clip the max and min to
	  TMP5=`g.tempfile pid=$$`
	  max=`eval r.info -r map=$meancurv | grep "max=" | cut -d"=" -f2`
	  min=`eval r.info -r map=$meancurv | grep "min=" | cut -d"=" -f2`

	  echo ""
	  echo "The raw max ($max) and min ($min) curvature will be rescaled from 2 to 0 "
	  echo ""

	  r.mapcalc "$rate=$kappa*(2-($meancurv*(2/($max)-($min))))"

	  #rate is actually the net change in bedrock elevation due to soil production, so lets use it to find the new bedrock elev, and the new soil depth!
	  r.mapcalc "$new_bdrk=$old_bdrk - $rate"
	  r.mapcalc "$new_soil=if (($new_dem - $new_bdrk) < 0, 0, ($new_dem - $new_bdrk))"

	  #these are the old soil equations that I failed to be able to implement... I leave them in for documentation purposes
	  #r.mapcalc "$new_bdrk=$initbdrk - ($Ba * ($Bb*($smoothdz - $initbdrk)))"
	  #r.mapcalc "$new_soil=if (($smoothdz - $initbdrk) < 0, 0, ($smoothdz - $initbdrk))"
	  g.remove --quiet rast=$rate,$meancurv
	fi

	#setting colors for new soil depth map
	r.colors --quiet  map=$new_soil rules=$TMP4

	#grabsomestats
	tmperosion=$prfx"tmperosion"$iter
	tmpdep=$prfx"tmpdep"$iter

	r.mapcalc "$tmperosion=if($netchange < 0, $netchange, null())"
	r.mapcalc "$tmpdep=if($netchange > 0, $netchange, null())"


	soilstats=`eval r.univar -g -e map=$new_soil percentile=99`
	maxsoil=`echo "$soilstats" | grep "max=" | cut -d'=' -f2`
	minsoil=`echo "$soilstats" | grep "min=" | cut -d'=' -f2`
	avesoil=`echo "$soilstats" | grep "mean=" | cut -d'=' -f2`
	nnthsoil=`echo "$soilstats" | grep "percentile_99=" | cut -d'=' -f2`

	erosstats=`eval r.univar -g -e map=$tmperosion percentile=1`
	maxeros=`echo "$erosstats" | grep "max=" | cut -d'=' -f2`
	mineros=`echo "$erosstats" | grep "min=" | cut -d'=' -f2`
	aveeros=`echo "$erosstats" | grep "mean=" | cut -d'=' -f2`
	nntheros=`echo "$erosstats" | grep "percentile_1=" | cut -d'=' -f2`

	depostats=`eval r.univar -g -e map=$tmpdep percentile=99`
	maxdepo=`echo "$depostats" | grep "max=" | cut -d'=' -f2`
	mindepo=`echo "$depostats" | grep "min=" | cut -d'=' -f2`
	avedepo=`echo "$depostats" | grep "mean=" | cut -d'=' -f2`
	nnthdepo=`echo "$depostats" | grep "percentile_99=" | cut -d'=' -f2`

	g.remove --quiet rast=$tmperosion,$tmpdep

	if [ -z $GIS_OPT_statsout ]; then
		
		mapset=`eval g.gisenv get=MAPSET`
		txtout=$mapset"_"$prefx"_lsevol_stats.txt"
		
	else
	
		txtout=$GIS_OPT_statsout
		
	fi
	
	echo "outputing stats to textfile: $txtout"
	if [ $GIS_FLAG_g -eq 1 ]; then
		
		if [ $iter -eq 1 ]; then
			echo "Stats for erosion and deposition simulation with starting map: $elev" > $txtout
			echo "" >> $txtout
			echo "Year,,Mean Erosion,Max Erosion,Min Erosion,99th Percentile Erosion,,Mean Deposition,Min Deposition,Max Deposition,99th Percentile Deposition,,Mean Soil Depth,Min Soil Depth,Max Soil Depth,99th Percentile Soil Depth" >> $txtout
		fi
		
		echo "$iter,,$aveeros,$mineros,$maxeros,$nntheros,,$avedepo,$mindepo,$maxdepo,$nnthdepo,,$avesoil,$minsoil,$maxsoil,$nnthsoil" >> $txtout
	else
		echo "$iter,,$aveeros,$mineros,$maxeros,$nntheros,,$avedepo,$mindepo,$maxdepo,$nnthdepo,,$avesoil,$minsoil,$maxsoil,$nnthsoil" >> $txtout

	fi
	echo ""
	echo "*************************"
	echo "Done with this iteration"
	echo "*************************"

	if [ $num_iters -eq 1 ]; then
	  if [ "$GIS_FLAG_e" -eq 1 ]; then
	    echo ""
	    echo "keeping initial soil depths map $new_soil"
	  else
	    g.remove --quiet rast=$new_tsoil
	  fi
	fi

	echo ""
	echo "If made, raster map $netchange shows filtered net erosion/deposition"
	echo ""
	echo "If made, raster map $soildepth shows soildpeths"
	echo ""
	echo "Raster map $new_dem shows new landscape (new elevations) after net erosion/depostion"
	echo "*************************"
	echo ""
done

#This is replaced by the large g.mremove process at the end of the script. I leave it commented because one might like to have the files for each iteration cleaned up as the process runs instead of one batch process at the end.
#if [ "$GIS_FLAG_k" -eq 1 ]; then
#	echo ""
#	echo "Done"
#	echo ""
#else
#	echo ""
#	echo "Cleaning up..."
#	g.remove rast=$flowacc,$slope,$aspect,$sflowtopo,$qsx,$qsy,$qsxdx,$qsydy,$erdep,$neighbors
#	echo ""
#	echo "Done"
#fi



# now we have met the loop critereon set by us above, so we have broken out.
if [ "$GIS_FLAG_c" -eq 1 ]; then
	r.mapcalc "$prefx"cum_erdep"=$new_dem-$elev"
	
	#set the colors to our rules
	r.colors --quiet  map=$prefx"cum_erdep" rules=$TMP1
fi

if [ "$GIS_FLAG_m" -eq 1 -o "$GIS_FLAG_t" -eq 1 ]; then
	
	liststring=`eval g.mlist type=rast sep=, pattern=$prefx"netchange*"`
	
	echo "Any selected statistics will be performed using the following netchange files: $liststring"

fi

if [ "$GIS_FLAG_m" -eq 1 ]; then

	r.series --q input=$liststring output=$prefx"ave_erdep" method=average 
	
	#set the colors to our rules
	r.colors --quiet  map=$prefx"ave_erdep" rules=$TMP1

fi

if [ "$GIS_FLAG_t" -eq 1 ]; then
	
	r.series --q input=$liststring output=$prefx"sdev_erdep" method=stddev 
	
	#set the colors to our rules
	r.colors --quiet  map=$prefx"sdev_erdep" rules=$TMP1

fi


if [ "$GIS_FLAG_s" -eq 1 -o "$GIS_FLAG_v" -eq 1 -o "$GIS_FLAG_a" -eq 1 -o "$GIS_FLAG_u" -eq 1 ]; then

	liststring2=`eval g.mlist type=rast sep=, pattern=$prefx$outsoil"*"`
	
	echo "Any selected statistics will be performed using the following soil depth files: $liststring2"

fi

if [ "$GIS_FLAG_s" -eq 1 ]; then

	r.series --q input=$liststring2 output=$prefx"ave_"$outsoil method=average 
fi

if [ "$GIS_FLAG_v" -eq 1 ]; then

	r.series --q input=$liststring2 output=$prefx"sdev_"$outsoil method=stddev 
fi

if [ "$GIS_FLAG_a" -eq 1 ]; then

	r.series --q input=$liststring2 output=$prefx"max_"$outsoil method=maximum 
fi

if [ "$GIS_FLAG_u" -eq 1 ]; then

	r.series --q input=$liststring2 output=$prefx"min_"$outsoil method=minimum 
fi

echo "************************"
echo ""

if [ "$GIS_FLAG_n" -ne 1 ]; then
  g.mremove -f --q rast=$prefx"netchange*"
fi



if [ "$GIS_FLAG_l" -eq 1 ]; then
  g.mremove --q rast=$prefx$outsoil"*"
fi

if [ "$GIS_FLAG_k" -eq 1 ]; then
  echo ""
  echo "Done"
  echo ""
else
  echo ""
  echo "Cleaning up..."
  g.mremove -f --quiet rast=$prefx"flowacc*"

  g.mremove -f --quiet rast=$prefx"slope*"

  g.mremove -f --quiet rast=$prefx"aspect*"

  g.mremove -f --quiet rast=$prefx"sflowtopo*"

  g.mremove -f --quiet rast=$prefx"qsx*"

  g.mremove -f --quiet rast=$prefx"qsy*"

  g.mremove -f --quiet rast=$prefx"erosdep*"

  g.mremove -f --quiet rast=$prefx"pc*"

  g.mremove -f --quiet rast=$prefx"tc*"

  g.mremove -f --quiet rast=$prefx"mexp*"

  g.mremove -f --quiet rast=$prefx"nexp*"

  g.mremove -f --quiet rast=$prefx"smoothdz*"


  echo ""
  echo "Done"
fi

#remove temporary color rule files
\rm -f $TMP1 $TMP1.sort
\rm -f $TMP4 $TMP4.sort

if [ "$GIS_FLAG_z" -eq 1 ]; then
  echo ""
  echo "Iterations complete, keeping region set to output maps"
  echo ""
else
  echo ""
  echo "Iterations complete, restoring default region settings"
  echo ""

  g.region -d -g

  echo ""
fi

echo "###################################################"
echo "###################################################"
echo "___________________________________________________"
echo ""
echo "            DONE WITH EVERYHTING"
echo ""
echo "___________________________________________________"




