#!/bin/sh

############################################################################
#
# MODULE:       i.despeckle
# AUTHOR(S):    Markus Neteler
# PURPOSE:      FGAMMA -- Gamma SAR Speckle Filter, based on
#               http://web.archive.org/web/20050826071553/http://www.pcigeomatics.com/cgi-bin/pcihlp/M_FGAMMA
#
# COPYRIGHT:    (C) 2012 GRASS Development Team/Markus Neteler
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
############################################################################
#%Module
#% description: Applies GAMMA SAR Speckle Filter to map.
#% keywords: imagery, filter, despeckle
#%End
#%Option
#% key: input
#% type: string
#% required: yes
#% multiple: no
#% key_desc: name
#% description: Name of input raster map
#% gisprompt: old,cell,raster
#%End
#%Option
#% key: output
#% type: string
#% required: yes
#% multiple: no
#% key_desc: name
#% description: Name for output raster map
#% gisprompt: new,cell,raster
#%End
#%Option
#% key: method
#% type: string
#% required: no
#% multiple: no
#% options: gamma
#% description: Despeckle operation
#% answer: gamma
#%End
#%Option
#% key: size
#% type: integer
#% required: no
#% multiple: no
#% description: Neighborhood size
#% answer: 3
#%End
#%Option
#% key: looks
#% type: integer
#% required: no
#% multiple: no
#% description: Number of looks (1: single look)
#% answer: 1
#%End


if [ -z "$GISBASE" ] ; then
    echo "You must be in GRASS GIS to run this program." 1>&2
    exit 1
fi

if [ "$1" != "@ARGS_PARSED@" ] ; then
    exec g.parser "$0" "$@"
fi

if [ $# -lt 1 -o "$1" = "help" -o "$1" = "-help"  -o "$1" = "-h" ] ; then
  echo "Usage: $0 sar_map"
  exit 1
fi



MAP=$GIS_OPT_INPUT
WIN=$GIS_OPT_SIZE
NumberLooks=$GIS_OPT_LOOKS
OUTPUT=$GIS_OPT_OUTPUT

######################
#        S   =   standard deviation of intensity within window   
r.neighbors in=$MAP out=$MAP.stddev method=stddev size=$WIN

#       Im  =   mean value of intensity within window
r.neighbors in=$MAP out=$MAP.mean method=average size=$WIN

#       Ci  =   S / Im
r.mapcalc "$MAP.ci = $MAP.stddev / $MAP.mean"

#       Cu  =   SQRT(1/NumberLooks)
Cu="`echo $NumberLooks | awk '{printf "%f", sqrt(1/$1)}'`"

#       Cmax =  SQRT(2)*Cu
Cmax="`echo $Cu | awk '{printf "%f", sqrt(2) * $1}'`"

#       A   =   (1+Cu^2)/(Ci^2-Cu^2)
r.mapcalc "$MAP.A = (1 + $Cu^2)/($MAP.ci^2 - $Cu^2)"

#       B   =   A-NumberLooks-1
r.mapcalc "$MAP.B = $MAP.A - $NumberLooks - 1"

#       D   =   Im*Im*B*B + 4*A*NumberLooks*Im*Ic
#       Ic  =   center pixel in filter window
r.mapcalc "$MAP.D = $MAP.mean * $MAP.mean * $MAP.B * $MAP.B + 4 * $MAP.A * $NumberLooks * $MAP.mean * $MAP"

#       Rf  =   (B*Im + SQRT(D))/(2*A)
r.mapcalc "$MAP.rf = ($MAP.B * $MAP.mean + sqrt($MAP.D)) / (2 * $MAP.A)"

#       R1   =   Im      for Ci <= Cu
#       R2   =   Rf      for Cu < Ci < Cmax
#       R3   =   Ic      for Ci >= Cmax

r.mapcalc "$OUTPUT = eval(r1 = $MAP.mean, r2 = $MAP.rf, r3 = $MAP, \\
     if($MAP.ci < $Cu, r1, \\
       if($MAP.ci > $Cu && $MAP.ci < $Cmax, r2, \\
         if($MAP.ci > $Cmax, r3, null() ) \\
       ) \\
     ))"

r.colors $OUTPUT col=grey -e

g.remove --q rast=$MAP.mean,$MAP.stddev,$MAP.rf,$MAP.ci,$MAP.A,$MAP.B,$MAP.D
echo "Written <$OUTPUT>"
