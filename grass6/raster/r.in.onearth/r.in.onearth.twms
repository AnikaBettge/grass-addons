#!/bin/sh
#############################################################################
# Download and import satellite images direct from the                      #
# NASA onearth WMS server into GRASS.                                       #
# written by Soeren Gebbert 11/2005 soerengebbert AT gmx de                 #
# and Markus Neteler. Support for pre-tiled WMS server by Hamish Bowman     #
#                                                                           #
# COPYRIGHT:	(C) 2005-2012 by the GRASS Development Team                 #
#                                                                           #
#		This program is free software under the GNU General Public  #
#		License (>=v2). Read the file COPYING that comes with GRASS #
#		for details.                                                #
#                                                                           #
#############################################################################

#%Module
#%  description: Download and import satellite images direct from the NASA onearth WMS server into GRASS or to a geo-tiff image file.
#%End
#%option
#%  key: output
#%  gisprompt: new,cell,raster
#%  type: string
#%  description: Output raster map name prefix
#%  required: no
#%end
#%option
#%  key: file
#%  gisprompt: file,file,file
#%  type: string
#%  description: Output file name prefix
#%  answer: /tmp/test
#%  required: no
#%end
#%flag
#%  key: f
#%  description: Do not import to GRASS, create a tiff file instead.
#%end
#%flag
#%  key: l
#%  description: Download and Import WMS Global Mosaic, a High Resolution, Global Coverage, Landsat TM 7 mosaic.
#%end
#%flag
#%  key: s
#%  description: Download and Import the radar reflectance images produced by the SRTM mission.
#%end
#%flag
#%  key: b
#%  description: Download and Import the Blue Marble Next Generation layer, one for each month of the year. 
#%end
#%flag
#%  key: t
#%  description: Download and Import the composite of data produced by the MODIS Rapid Response System, from data collected yesterday by the MODIS/Terra.
#%end
#%flag
#%  key: a
#%  description: Download and Import the composite of data produced by the MODIS Rapid Response System, from data collected yesterday by the MODIS/Aqua.
#%end
#%option
#%  key: tmband
#%  type: string
#%  description: NASA Landsat TM bands
#%  options: Red,Green,Blue,IR1,IR2,IR3,ThL,ThH,Pan,visual,pseudo 
#%  required: no
#%end
#%option
#%  key: srtmband
#%  type: string
#%  description: Radar reflectance bands
#%  options:  default,ss1,ss2,ss3,ss4,all 
#%  required: no
#%end
#%option
#%  key: month
#%  type: string
#%  description: Blue Marble Next Generation layer
#%  options: Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec 
#%  required: no
#%end
#%option
#%  key: time
#%  type: string
#%  description: The datum of creation for Aqua or Terra satellite images
#%  answer: 2005-3-24    
#%  required: no
#%end
#%option
#%  key: wgetopt
#%  type: string
#%  description: Options for wget
#%  answer: -c -t 5
#%  required: no
#%end


#Only run if started in GRASS
if [ -z "$GISBASE" ] ; then
    echo "You must be in GRASS GIS to run this program." >&2
    exit 1
fi

#Parse the arguments
if [ "$1" != "@ARGS_PARSED@" ] ; then
  exec g.parser "$0" "$@"
fi


#Set up important vars first
SRC="EPSG:4326" #This is the Projection LatLong wgs84
FORMAT="image/geotiff" #GeoTiff import for r.in.gdal
NASASERVER="http://wms.jpl.nasa.gov/wms.cgi" #this server may change
TYPE=""
TIME=""
IMPORT=0 #0 is true
GLOBAL_MOSAIC_LAYER="global_mosaic_base" #Thats the NASA WMS Global Mosaic database
SRTM_MAG_LAYER="srtm_mag" #Thats the NASA srtm_mag database
BMNG_LAYER="BMNG" #Thats the Blue Marble Next Generation database
DAILY_TERRA_LAYER="daily_terra" #Thats the NASA daily terra database
DAILY_AQUA_LAYER="daily_aqua" #Thats the NASA daily aqua database
USE_GDALWARP="true" #if we dont have gdalwarp, only LatLong projection is supported
FILE_EXTENT=".tif"


# check if we have wget
if [ ! -x "`which wget`" ] ; then
    g.message -e "wget required, please install first"
    exit 1
fi

# check if we have gdalwarp
if [ ! -x "`which gdalwarp`" ] ; then
    g.message -w "gdalwarp is recommended, please install first (script still works in LatLong locations)"
    USE_GDALWARP="false"  #use only LatLong
fi


############
# for now just support lat/lon
USE_GDALWARP="false"
############

eval `g.region -g`
if [ "$nsres" != "$ewres" ] ; then
    g.message -e "East-West and North-South region resolution must be the same"
    exit 1
else
    res="$nsres"
fi

case "$res" in
   0.125 | 0.25 | 0.5 | 1 | 2 | 4 | 8 | 16 | 32 | 64)
        value="valid"
        ;;
   *)
        value="invalid"
        g.message -e "Resolution must be one of "
        g.message -e "       {0.125 0.25 0.5 1 2 4 8 16 32 64}"
        exit 1
        ;;
esac



#######################################################
# start of todo code dump


#### adjust region to snap to grid
# setup internal region
g.region save="tmp_tiled_wms.$$"
WIND_OVERRIDE="tmp_tiled_wms.$$"
export WIND_OVERRIDE



# snap lat,long to upper-left corner of nearest tile grid node
# Round lat to nearest grid node
#todo: awkify:
lat = 90.0 - round((90.0 - lat) / $res) * $res;
lon = -180.0 + floor((180.0 + lon) / $res) * $res;

#maybe floor() lower left lat/lon, ceil() for upper right lat/lon
# ?


BASE_URL="http://onearth.jpl.nasa.gov/wms.cgi"
BASE_REQUEST="request=GetMap&layers=$LAYER&srs=EPSG:4326&width=512&height=512"
BASE_META="format=image/jpeg&version=1.1.1&styles=$STYLE"
URL="$BASE_URL?$BASE_REQUEST&$BBOX&$BASE_META"

#bbox=minx,miny,maxx,maxy

#top row
minx=$(echo "$lon $res" | awk '{printf("%.9f", $1 - $2)}')
miny="$lat"
maxx="$lon"
maxy=$(echo "$lat $res" | awk '{printf("%.9f", $1 + $2)}')
BBOX_11="$minx,$miny,$maxx,$maxy"

minx="$lon"
miny="$lat"
maxx=$(echo "$lon $res" | awk '{printf("%.9f", $1 + $2)}')
maxy=$(echo "$lat $res" | awk '{printf("%.9f", $1 + $2)}')
BBOX_21="$minx,$miny,$maxx,$maxy"

minx=$(echo "$lon $res" | awk '{printf("%.9f", $1 + $2)}')
miny="$lat"
maxx=$(echo "$lon $res" | awk '{printf("%.9f", $1 + (2 * $2))}')
maxy=$(echo "$lat $res" | awk '{printf("%.9f", $1 + $2)}')
BBOX_31="$minx,$miny,$maxx,$maxy"

#bottom row
minx=$(echo "$lon $res" | awk '{printf("%.9f", $1 - $2)}')
miny=$(echo "$lat $res" | awk '{printf("%.9f", $1 - $2)}')
maxx="$lon"
maxy="$lat"
BBOX_12="$minx,$miny,$maxx,$maxy"

minx="$lon"
miny=$(echo "$lat $res" | awk '{printf("%.9f", $1 - $2)}')
maxx=$(echo "$lon $res" | awk '{printf("%.9f", $1 + $2)}')
maxy="$lat"
BBOX_22="$minx,$miny,$maxx,$maxy"

minx=$(echo "$lon $res" | awk '{printf("%.9f", $1 + $2)}')
miny=$(echo "$lat $res" | awk '{printf("%.9f", $1 - $2)}')
maxx=$(echo "$lon $res" | awk '{printf("%.9f", $1 + (2 * $2))}')
maxy="$lat"
BBOX_32="$minx,$miny,$maxx,$maxy"



#top row
URL="$BASE_URL?$BASE_REQUEST&bbox=$BBOX_11&$BASE_META"
wget -nv "$URL" -O twms_11.jpg &

URL="$BASE_URL?$BASE_REQUEST&bbox=$BBOX_21&$BASE_META"
wget -nv "$URL" -O twms_21.jpg &

URL="$BASE_URL?$BASE_REQUEST&bbox=$BBOX_31&$BASE_META"
wget -nv "$URL" -O twms_31.jpg
wait


#bottom row
URL="$BASE_URL?$BASE_REQUEST&bbox=$BBOX_12&$BASE_META"
wget -nv "$URL" -O twms_12.jpg &

URL="$BASE_URL?$BASE_REQUEST&bbox=$BBOX_22&$BASE_META"
wget -nv "$URL" -O twms_22.jpg &

URL="$BASE_URL?$BASE_REQUEST&bbox=$BBOX_32&$BASE_META"
wget -nv "$URL" -O twms_32.jpg
wait


#### some checks before going on
if [ `ls -1 twms_*.jpg | wc -l` -lt 6 ] ; then
    echo "ERROR: Tile(s) appear to be missing." 1>&2
    if [ "$verbose" = "true" ] ; then
        ls twms_*.jpg
    fi
    # todo: look to see which one is missing and try again.
    cd ..
    rm -rf "$TEMPDIR2"
    exit 1
fi

for file in twms_*.jpg ; do
    if [ ! -s "$file" ] ; then
        echo "ERROR: <$file> appears to be empty." 1>&2
        if [ "$verbose" = "true" ] ; then
            ls -l twms_*.jpg
        fi
        cd ..
        rm -rf "$TEMPDIR2"
        exit 1
    fi
    if [ `file "$file" | grep -c JPEG` -eq 0 ] ; then
        echo "ERROR: <$file> appears to be bogus." 1>&2
        if [ `file "$file" | grep -c XML` -eq 1 ] && [ "$verbose" = "true" ] ; then
           cat "$file"
        fi
        cd ..
        rm -rf "$TEMPDIR2"
        exit 1
    fi
done

if [ "$verbose" = "true" ] ; then
   echo "Converting to pnm ..." 1>&2
fi

for file in twms_*.jpg ; do
    jpegtopnm "$file" > `basename "$file" .jpg`.pnm
done


if [ "$verbose" = "true" ] ; then
   echo "Patching ..." 1>&2
fi
pnmcat -lr twms_11.pnm twms_21.pnm twms_31.pnm > row1.pnm
pnmcat -lr twms_12.pnm twms_22.pnm twms_32.pnm > row2.pnm
pnmcat -tb row1.pnm row2.pnm | pnmcut 0 0 1280 1024 | \
   pnmtojpeg --quality=75 > mosaic.jpg

rm -f twms_*.pnm twms_*.jpg row[0-9].pnm



# end of todo code dump
#######################################################






#Some functions
#Get the data from the NASA server
GetData()
{
   IMPORT=0 #default
   local STRING="request=GetMap&layers=$LAYER&srs=$SRC&width=$WIDTH&height=$HEIGHT&bbox=$w,$s,$e,$n&format=$FORMAT&version=1.1.0&styles=$STYLE$TIME"
   #echo $STRING
   #Create thefilename
   IMAGEFILE="$TMPDIR/Image_${LAYER}_${STYLE}_${HEIGHT}_$WIDTH"
   g.message -v "**** DOWNLOAD DATA ****"
   g.message -v "Requesting Data from $NASASERVER"

   #download the File from the Server
   wget $WGET_OPTIONS --post-data="$STRING" "$NASASERVER" -O "$IMAGEFILE" 

   if [ $? -ne 0 ] ; then
     g.message -e "wget was not able to download the data"
     IMPORT=1
     return 1
   fi

   if [ -f "$IMAGEFILE" ] ; then 
     IMPORT=0
   else
     g.message -e "wget was not able to download the data"
     IMPORT=1
     return 1
   fi
return 0
}


#warp the data to the current grass locationa via gdalwarp
WarpData()
{
    if [ "$USE_GDALWARP" = "true" ] ; then 
        g.message -v "**** CONVERT DATA  ****"
        #create the new imagename
	IMAGEFILE_GDALWARP="$TMPDIR/Image_${LAYER}_${STYLE}_${HEIGHT}_${WIDTH}_gdalwarp"

   	#convert the data to the current location, create Erdas Imagine Images (HFA)
	gdalwarp -s_srs "$SRC" -t_srs "`g.proj -wf`" -of HFA \
	    "$IMAGEFILE" "$IMAGEFILE_GDALWARP"
	if [ $? -ne 0 ] ; then
          g.message -i '!-------- CAN NOT CONVERT DATA --------!'
          g.message -i '!------------ WILL BREAK --------------!'
	  exitprocedure
	fi
        g.message -v "**** DATA CONVERTED ****"
	#remove the old image and convert the name
	rm -f "$IMAGEFILE"
	IMAGEFILE="$IMAGEFILE_GDALWARP"
	return 0
    fi
    return 1
}


#Import the Data with r.in.gdal
ImportData()
{
   if [ "$IMPORT" -eq 0 ] ; then 
	#Check if Tiff file
	FILETYPE=`file  "$IMAGEFILE" | cut --fields=2 --delimiter=:`
	echo "$FILETYPE" | grep TIFF > /dev/null
	if [ $? -ne 0 ] ; then
	    g.message -i "Downloaded file is not a GeoTiff file, but will try to import"
	fi
	g.message -v "**** CHECK DATA ****"
	gdalinfo "$IMAGEFILE" | grep "GDALOpen failed" > /dev/null
	local ReturnValueGdalBug=$?
	
	gdalinfo "$IMAGEFILE"
	local ReturnValueGdal=$?

	if [ "$ReturnValueGdal" -eq 0 ] && [ "$ReturnValueGdalBug" -ne 0 ] ; then
	    g.message -v "**** DATA CHECK OK ****"
	    #Copy or import
	    if [ "$GIS_FLAG_F" -eq 1 ] ; then
		#Copy the data to the outputfile
		g.message -v "Creating output file $GIS_OPT_FILE$TYPE$STYLE$FILE_EXTENT"
		cp "$IMAGEFILE" "$GIS_OPT_FILE$TYPE$STYLE$FILE_EXTENT"
	    else
		#Warp the data!
		WarpData
		g.message -v "**** IMPORT DATA ****"
		r.in.gdal -o input="$IMAGEFILE" \
		     output="$GIS_OPT_OUTPUT${TYPE}_$STYLE"
	    fi
	else
	    echo '!-------------------BREAK---------------------!'
	    echo "Downloaded file is not supported by gdal, or cannot be imported"
	    if [ $ReturnValueGdalBug -eq 0 ] ; then
		echo "There was a problem while downloading the file, maybe you should try it again."
	    fi
	    g.message -v "File of Type: $FILETYPE"
	    #If the File is XML, then cat the contents to stdout
	    echo "$FILETYPE" | grep XML > /dev/null
	    if [ $? -eq 0 ] ; then
		g.message " "
		g.message "Message from Server $NASASERVER"
		echo " "
        	echo '!------------BEGIN-ERROR-MESSGAE--------------!'
		cat "$IMAGEFILE"
        	echo '!-------------END-ERROR-MESSGAE---------------!'
	    fi
	fi
	rm -rf "$IMAGEFILE"
    fi
    return 0
}


# what to do in case of user break:
exitprocedure()
{
    g.message 'User break!'
    rm -rf "$TMPDIR"
    unset WIND_OVERRIDE
    g.remove region="tmp_tiled_wms.$$" --quiet
    exit 1
}
trap "exitprocedure" 2 3 15


#At least one flag should be set
if [ $GIS_FLAG_L -eq 0  -a  $GIS_FLAG_S -eq 0  -a  $GIS_FLAG_B -eq 0 ] \
   && [ $GIS_FLAG_T -eq 0  -a  $GIS_FLAG_A -eq 0 ] ; then
    g.message -e "Select a flag to specify map type"
    exit 1
fi

#Check if a file or a map should be created
if [ "$GIS_FLAG_F" -eq 1 ] ; then
    if [ -z "$GIS_OPT_FILE"] ; then
  	g.message -e "Please specify the output filename"
	exit 1
    fi
fi

#Some mapset informations 
eval `g.gisenv`
: ${GISBASE?} ${GISDBASE?} ${LOCATION_NAME?} ${MAPSET?}
LOCATION="$GISDBASE/$LOCATION_NAME/$MAPSET"
PERM="$GISDBASE/$LOCATION_NAME/PERMANENT"

#wget has many options
WGET_OPTIONS="$GIS_OPT_WGETOPT"

#Get the region data 
eval `g.region -g`
WIDTH="$cols"
HEIGHT="$rows"
eval `g.region -gb`
#Now get the LatLong Boundingbox
grep -i 'proj: ll' $PERM/PROJ_INFO > /dev/null
if [ $? -ne 0 ] && [ "$USE_GDALWARP" = "true" ] ; then
    n="$ll_n"
    s="$ll_s"
    e="$ll_e"
    w="$ll_w"
    g.message -v "LatLong wgs84 bounding box = N $n S $s W $w E $e"
else
    #We have LatLong projection, no warp is needed!
    USE_GDALWARP="false"
    #There is a bug in nasa WMS service, it provides images which are lager then
    #the world :(, we have to crop the images
    if [ "$n" = "90" -a "$s" = "-90" ] && \
       [ "$w" = "-180" -a "$e" = "180" ] ; then

	# check if we have bc
	if [ ! -x "`which bc`" ] ; then
	    g.message -e "bc required, please install first"
	    exit 1
	fi
	#We request a smaller image from the wms server
	n=`echo "$n - 0.001" | bc`
	s=`echo "$s + 0.001" | bc`
	e=`echo "$e - 0.001" | bc`
	w=`echo "$w + 0.001" | bc`
    fi
fi

#Break If we have no warp and no LatLong
grep -i 'proj: ll' "$PERM/PROJ_INFO" > /dev/null
if [ $? -ne 0 ] && [ "$USE_GDALWARP" = "false" ] ; then
    g.message -e "NASA OnEarth data are in Latitude/Longitude. The \
                  current location projection differs and you don't \
		  have gdalwarp! STOP."
    exit 1
fi


#make a temporary directory
TMPDIR="`g.tempfile pid=$$`"
if [ $? -ne 0 ] || [ -z "$TMPDIR" ] ; then
    g.message -e "Unable to create temporary files"
    exit 1
fi
rm -f "$TMPDIR"
mkdir "$TMPDIR"

#Get the Data and import them
#import every choice that can be made

if [ $GIS_FLAG_L -eq 1 ] ; then
    LAYER="$GLOBAL_MOSAIC_LAYER"
    STYLE="$GIS_OPT_TMBAND"
    TYPE="LandsatTM"
    g.message -v "Will download and import $TYPE Data with band $STYLE"
    GetData
    ImportData
fi


if [ $GIS_FLAG_S -eq 1 ] ; then
    LAYER="$SRTM_MAG_LAYER"
    STYLE="$GIS_OPT_SRTMBAND"
    TYPE="SRTM"
    g.message -v "Will download and import $TYPE Data with band $STYLE"
    GetData
    ImportData
fi

if [ $GIS_FLAG_B -eq 1 ] ; then
    LAYER="$BMNG_LAYER"
    STYLE="$GIS_OPT_MONTH"
    TYPE="BMNG"
    g.message -v "Will download and import $TYPE Data of month $STYLE"
    GetData
    ImportData
fi

if [ $GIS_FLAG_T -eq 1 ] ; then
    LAYER="$DAILY_TERRA_LAYER"
    TIME="&time=$GIS_OPT_TIME"
    STYLE=""
    TYPE="Daily_Terra"
    g.message -v "Will download and import $TYPE Data"
    GetData
    ImportData
fi

if [ $GIS_FLAG_A -eq 1 ] ; then
    LAYER="$DAILY_AQUA_LAYER"
    TIME="&time=$GIS_OPT_TIME"
    STYLE=""
    TYPE="Daily_Aqua"
    g.message -v "Will download and import $TYPE Data"
    GetData
    ImportData
fi

#remove the temp dir
rm -rf "$TMPDIR"

unset WIND_OVERRIDE
g.remove region="tmp_tiled_wms.$$" --quiet

g.message -v "Finished"

exit 0
