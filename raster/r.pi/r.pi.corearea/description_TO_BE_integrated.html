</head>
<body bgcolor="white">

<img src="grass_logo.png" alt="GRASS logo"><hr align=center size=6 noshade>

<h2>NAME</h2>
<em><b>r.pi.index</b></em>  - is part of a patch based fragmentation analysis package (<EM>r.pi</EM>) providing basic patch based indices, like area, SHAPE or Nearest Neighbour distance.
<h2>KEYWORDS</h2>
raster, patch index, landscape ecology
<h2>SYNOPSIS</h2>
<b>r.pi.index</b><br>
<b>r.pi.index help</b><br>
<b>r.pi.index</b> [-<b>a</b>] <b>input</b>=<em>name</em> <b>output</b>=<em>name</em> 
<b>keyval</b>=<em>val</em>   <b>method</b>=<em>name</em> [<b>title</b>=<em>name</em>]   [--<b>overwrite</b>]  [--<b>verbose</b>]  [--<b>quiet</b>] 

<h3>Flags:</h3>
<DL>
<DT><b>-a</b></DT>
<DD>use 8-neighbour rules (Queen-Typ) instead of 4-neighbour rule (Rook-Typ)</DD>

<DT><b>--overwrite</b></DT>
<DD>Allow output files to overwrite existing files</DD>
<DT><b>--verbose</b></DT>
<DD>Verbose module output</DD>
<DT><b>--quiet</b></DT>
<DD>Quiet module output</DD>
</DL>



<h3>Parameters:</h3>
<DL>
<DT><b>input</b>=<em>name</em></DT>
<DD>Name of existing raster map containing categories</DD>

<DT><b>output</b>=<em>name</em></DT>
<DD>Output patch-based result raster map</DD>

<DT><b>keyval</b>=<em>val</em></DT>
<DD>The value of the class to analyse</DD>

<DT><b>method</b>=<em>name</em></DT>
<DD>The index to compute. Options: area, perimeter (perim), SHAPE, Border-Index (bor), Compactness (comp), Asymmetry (asym), area-perimeter ratio (apr), fractal dimension (fract), distance to euclidean nearest neighbour (ENN)</DD>

<DT><b>title</b>=<em>name</em></DT>
<DD>Optional title of output map</DD>

</DL>



<H2>DESCRIPTION</H2>

<P>

The program will be run non-interactively if the user specifies program arguments (see OPTIONS) on the command
line.  Alternately, the user can simply type <B>r.pi.index</B> on the command line, without program
arguments.  In this case, the user will be prompted for flag settings and parameter values.

> Was die propmap angeht:
>
> Wenn du nur 0 Werte nimmst, dann werden die Werte immer unendlich
> propagiert. Es geht nämlich so:
>
> propmethod=linear: propagierter Wert = aktueller Wert - (propmap an
> dieser Stelle)
>
> propmethod=exponential: propagierter Wert = aktueller Wert / (propmap
> an dieser Stelle)
>
> Bei 0 in der map ist also bei linearer Methode immer
> propagierter Wert = aktueller Wert und daher wird eigentlich alles
> weggebuffert. Dass da einige übriggeblieben sind, hing mit dem anderen
> Bug zusammen (oder vllt. gibt's noch einen Bug?). Jedenfalls sollten
> dann wirklich alle Patches weg sein.
>
> Um die Weite der Propagierung abzuschwächen muss man die Werte in der
> Propmap größer als 1 wählen. Bei der exponentiellen Methode sollte
> grundsätzlich nie ein Wert unter 1 gewählt werden, denn sonst wird
> auch ins Unendliche propagiert.




w(d) = 1 - (d / d_max)^(tan(dist_weight * 0.5 * pi))

dabei ist:

d - die Distanz der jeweiligen Zelle
d_max - die angegebene maximale Distanz
dist_weight - der Parameter

Es schaut damit wie folgt aus:

0 < dist_weight < 0.5: die Bewertungskurve ist am Anfang steil
abfallend und wird flacher bis zum Wert 0 bei d = d_max

dist_weight = 0.5: linearer Abstieg zum Wert 0 bei d = d_max

0.5 < dist_weight < 1: Kurve fällt flach und dann immer steiler bis
zum Wert 0 bei d = d_max

dist_weight = 1: Keine Distanzbewertung, d.h. so wie vorher

<DT><B>Area</B> 

<DD>The <EM>Area</EM> (area) computes the area of each patch.


<DT><B>Perimeter</B> 

<DD>The <EM>Perimeter (perim)</EM> computes the perimeter of each patch.


<DT><B>Area-Perimeter ratio </B> 

<DD>The <EM>Area-Perimeter ratio</EM> (apr) divides the patch perimeter by the area.


<DT><B>SHAPE Index </B> 

<DD>The <EM>SHAPE Index</EM> (shape) divides the patch perimete by the minimum perimeter 
possible for a maximally compact patch of the corresponding patch area.



<DT><B>Border Index </B> 

<DD>The <EM>Border Index</EM> (bor)....


<DT><B>Compactness Index </B> 

<DD>The <EM>Compactness Index</EM> (comp)....


<DT><B>Asymmetry Index </B> 

<DD>The <EM>Border Index</EM> (asym)....


<DT><B>Fractal Dimension Index </B> 

<DD>The <EM>Fractal Dimension Index</EM> (fract)....


<DT><B>Nearest Neighbour Index </B> 

<DD>The <EM>Nearest Neighbour Index</EM> (ENN) ....


<!-- Bsp um Pseudo code or Bsp einzufügen -->
<!--<div class="code"><pre>
Input:                          Output:
  ELEVATION SURFACE               LEAST COST PATH
. . ----- . . . . . . . . . .    . . . . . . . . . . . . . . .
. 20| 19| 17. 16. 17. 16. 16.    .   . 1 . 1 . 1 .   .   .   .
. . |___| . . . . . . . . . .    . . . . . . . . . . . . . . .
. 18. 18. 24. 18. 15. 12. 11.    .   .   .   .   . 1 .   .   .
. . . . . . . . . . . . . . .    . . . . . . . . . . . . . . .
. 22. 16. 16. 18. 10. 10. 10.    .   .   .   .   . 1 .   .   .
. . . . . . . . . . . . . . .    . . . . . . . . . . . . . . .
. 17. 15. 15. 15. 10. 8 . 8 .    .   .   .   .   .   . 1 .   .
. . . . . . . . . . . . . . .    . . . . . . . . . . . . . . .
. 24. 16. 8 . 7 . 8 . 0 .12 .    .   .   .   .   .   . 1 .   .
. . . . . . . . . . . . . . .    . . . . . . . . . . . . . . .
. 17. 9 . 8 . 7 . 8 . 6 .12 .    .   .   .   .   .   .   .   .
. . . . . . . . . . . . . . .    . . . . . . . . . . . . . . .
</pre></div>-->




</DL>
<H2>NOTES</H2>




<P>

<H2>BUGS</H2>



<H2>SEE ALSO</H2>

<EM><A HREF="r.pi.ENN.html">r.pi.ENN</A></EM><br>
<EM><A HREF="r.pi.FNN.html">r.pi.FNN</A></EM><br>
<EM><A HREF="r.pi.dist.html">r.pi.dist</A></EM><br>
<EM><A HREF="r.li.setup.html">r.li.setup</A></EM><br>

<H2>AUTHOR</H2>

Programming: Elshad Shirinov<br>
Scientific concept: Martin Wegmann <br>
University of Wuerzburg<br>


<p><i>Last changed: $Date$</i>
