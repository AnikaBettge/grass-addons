</head>
<body bgcolor="white">

<img src="grass_logo.png" alt="GRASS logo"><hr align=center size=6 noshade>

<h2>NAME</h2>
<em><b>r.pi.index</b></em>  - is part of a patch based fragmentation analysis package (<em>r.pi</em>) providing basic patch based indices, like area, SHAPE or Nearest Neighbour distance.
<h2>KEYWORDS</h2>
raster, patch index, landscape ecology
<h2>SYNOPSIS</h2>
<b>r.pi.index</b><br>
<b>r.pi.index help</b><br>
<b>r.pi.index</b> [-<b>a</b>] <b>input</b>=<em>name</em> <b>output</b>=<em>name</em> 
<b>keyval</b>=<em>val</em>   <b>method</b>=<em>name</em> [<b>title</b>=<em>name</em>]   [--<b>overwrite</b>]  [--<b>verbose</b>]  [--<b>quiet</b>] 

<h3>Flags:</h3>
<dl>
<dt><b>-a</b></dt>
<dd>use 8-neighbour rules (Queen-Typ) instead of 4-neighbour rule (Rook-Typ)</dd>

<dt><b>--overwrite</b></dt>
<dd>Allow output files to overwrite existing files</dd>
<dt><b>--verbose</b></dt>
<dd>Verbose module output</dd>
<dt><b>--quiet</b></dt>
<dd>Quiet module output</dd>
</dl>



<h3>Parameters:</h3>
<dl>
<dt><b>input</b>=<em>name</em></dt>
<dd>Name of existing raster map containing categories</dd>

<dt><b>output</b>=<em>name</em></dt>
<dd>Output patch-based result raster map</dd>

<dt><b>keyval</b>=<em>val</em></dt>
<dd>The value of the class to analyse</dd>

<dt><b>method</b>=<em>name</em></dt>
<dd>The index to compute. Options: area, perimeter (perim), SHAPE, Border-Index (bor), Compactness (comp), Asymmetry (asym), area-perimeter ratio (apr), fractal dimension (fract), distance to euclidean nearest neighbour (ENN)</dd>

<dt><b>title</b>=<em>name</em></dt>
<dd>Optional title of output map</dd>

</dl>



<h2>DESCRIPTION</h2>

<p>

The program will be run non-interactively if the user specifies program arguments (see OPTIONS) on the command
line.  Alternately, the user can simply type <b>r.pi.index</b> on the command line, without program
arguments.  In this case, the user will be prompted for flag settings and parameter values.

> Was die propmap angeht:
>
> Wenn du nur 0 Werte nimmst, dann werden die Werte immer unendlich
> propagiert. Es geht nämlich so:
>
> propmethod=linear: propagierter Wert = aktueller Wert - (propmap an
> dieser Stelle)
>
> propmethod=exponential: propagierter Wert = aktueller Wert / (propmap
> an dieser Stelle)
>
> Bei 0 in der map ist also bei linearer Methode immer
> propagierter Wert = aktueller Wert und daher wird eigentlich alles
> weggebuffert. Dass da einige übriggeblieben sind, hing mit dem anderen
> Bug zusammen (oder vllt. gibt's noch einen Bug?). Jedenfalls sollten
> dann wirklich alle Patches weg sein.
>
> Um die Weite der Propagierung abzuschwächen muss man die Werte in der
> Propmap größer als 1 wählen. Bei der exponentiellen Methode sollte
> grundsätzlich nie ein Wert unter 1 gewählt werden, denn sonst wird
> auch ins Unendliche propagiert.




w(d) = 1 - (d / d_max)^(tan(dist_weight * 0.5 * pi))

dabei ist:

d - die Distanz der jeweiligen Zelle
d_max - die angegebene maximale Distanz
dist_weight - der Parameter

Es schaut damit wie folgt aus:

0 < dist_weight < 0.5: die Bewertungskurve ist am Anfang steil
abfallend und wird flacher bis zum Wert 0 bei d = d_max

dist_weight = 0.5: linearer Abstieg zum Wert 0 bei d = d_max

0.5 < dist_weight < 1: Kurve fällt flach und dann immer steiler bis
zum Wert 0 bei d = d_max

dist_weight = 1: Keine Distanzbewertung, d.h. so wie vorher

<dt><b>Area</b> 

<dd>The <em>Area</em> (area) computes the area of each patch.


<dt><b>Perimeter</b> 

<dd>The <em>Perimeter (perim)</em> computes the perimeter of each patch.


<dt><b>Area-Perimeter ratio </b> 

<dd>The <em>Area-Perimeter ratio</em> (apr) divides the patch perimeter by the area.


<dt><b>SHAPE Index </b> 

<dd>The <em>SHAPE Index</em> (shape) divides the patch perimete by the minimum perimeter 
possible for a maximally compact patch of the corresponding patch area.



<dt><b>Border Index </b> 

<dd>The <em>Border Index</em> (bor)....


<dt><b>Compactness Index </b> 

<dd>The <em>Compactness Index</em> (comp)....


<dt><b>Asymmetry Index </b> 

<dd>The <em>Border Index</em> (asym)....


<dt><b>Fractal Dimension Index </b> 

<dd>The <em>Fractal Dimension Index</em> (fract)....


<dt><b>Nearest Neighbour Index </b> 

<dd>The <em>Nearest Neighbour Index</em> (ENN) ....


<!-- Bsp um Pseudo code or Bsp einzufügen -->
<!--<div class="code"><pre>
Input:                          Output:
  ELEVATION SURFACE               LEAST COST PATH
. . ----- . . . . . . . . . .    . . . . . . . . . . . . . . .
. 20| 19| 17. 16. 17. 16. 16.    .   . 1 . 1 . 1 .   .   .   .
. . |___| . . . . . . . . . .    . . . . . . . . . . . . . . .
. 18. 18. 24. 18. 15. 12. 11.    .   .   .   .   . 1 .   .   .
. . . . . . . . . . . . . . .    . . . . . . . . . . . . . . .
. 22. 16. 16. 18. 10. 10. 10.    .   .   .   .   . 1 .   .   .
. . . . . . . . . . . . . . .    . . . . . . . . . . . . . . .
. 17. 15. 15. 15. 10. 8 . 8 .    .   .   .   .   .   . 1 .   .
. . . . . . . . . . . . . . .    . . . . . . . . . . . . . . .
. 24. 16. 8 . 7 . 8 . 0 .12 .    .   .   .   .   .   . 1 .   .
. . . . . . . . . . . . . . .    . . . . . . . . . . . . . . .
. 17. 9 . 8 . 7 . 8 . 6 .12 .    .   .   .   .   .   .   .   .
. . . . . . . . . . . . . . .    . . . . . . . . . . . . . . .
</pre></div>-->




</dl>
<h2>NOTES</h2>




<p>

<h2>BUGS</h2>



<h2>SEE ALSO</h2>

<em><a href="r.pi.ENN.html">r.pi.ENN</a></em><br>
<em><a href="r.pi.FNN.html">r.pi.FNN</a></em><br>
<em><a href="r.pi.dist.html">r.pi.dist</a></em><br>
<em><a href="r.li.setup.html">r.li.setup</a></em><br>

<h2>AUTHOR</h2>

Programming: Elshad Shirinov<br>
Scientific concept: Martin Wegmann <br>
University of Wuerzburg<br>


<p><i>Last changed: $Date$</i>
